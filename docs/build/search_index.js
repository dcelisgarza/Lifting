var documenterSearchIndex = {"docs":
[{"location":"#Do-You-Even-Lift,-Bro?-1","page":"Home","title":"Do You Even Lift, Bro?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"if lift == true\r\n    println(\"Yeaah buddy! Lightweight baby! Oooooooooooh\")\r\nelse\r\n    println(\"Weak!\")\r\n    return\r\nend","category":"page"},{"location":"#Ain't-nuthin'-but-a-peanut!-1","page":"Home","title":"Ain't nuthin' but a peanut!","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There is no reason to be alive if you can't do deadlifts!\"  Jon Pall Sigmarsson","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is a tool for creating and analysing lifting programmes. It comes with a few premade dictionaries that users can import and modify to make things easier on them. These defaults as well as the programme I'm currently following are found in /src/assets. More details in Defaults.","category":"page"},{"location":"#Lightweight,-Baby!-1","page":"Home","title":"Lightweight, Baby!","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Just remember, somewhere, a little Chinese girl is warming up with your max.     Jim Conroy","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In order to make a programme you need 3 things:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"an exercise,\na progression,\na schedule.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We shall pretend to be Brosef, that annoying guy at the gym whose 'programme' consists of bench pressing every day, staring at girls all sesh–-incidentally, said girls definitely squat more than him–-and is a neverending font of unsolicited life, lifting, relationship and medical advice that is verifiably false.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We must first create the b e n c h p r e s s, emissary of the bro'onites.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BenchPress = Exercise(;\r\n    name = \"Bench Press\",\r\n    modality = \"Half Rep\",   # Also accepts vectors. Defaults to \"Default\".\r\n    equipment = \"Barbell\",  # Also accepts vectors. Defaults to \"NA\".\r\n    size = \"YUGE\", # Also accepts vectors. Defaults to \"NA\".\r\n    muscles = [\r\n                muscles[\"triceps\"],\r\n                muscles[\"front delts\"]\r\n              ],        # Also accepts scalars. Defaults to \"NA\".\r\n    trainingMax = 100,  # Defaults to 0.\r\n    roundBase = 2.5,    # Round to nearest multiple. Defaults to 2.5.\r\n    roundMode = floor,  # Rounding function. Defaults to floor.\r\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Of course, Brosef is a 'bodybuilder' and is all about dat TUT 'bout dat TUT (time under tension), so he exclusively works at high reps and low intensities despite completing maybe 25% of the rep on a good day. He also takes at least 5 minutes between sets because he needs to replenish his \"ATT\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# The arrays must all be of equal length. Entry indices correspond to each other.\r\nTUT = SetScheme(;\r\n    type = [\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"],\r\n    sets = [1, 2, 1, 1],\r\n    reps = [12, 14, 10, 5],\r\n    intensity = [\r\n                  9.5, # Intensity, can be percentage based (decimal form) or RPE\r\n                  10,  # based. Percentages are capped at 1, RPE at 10.\r\n                  10,\r\n                  10\r\n                ],  \r\n    roundMode = [\r\n                  floor,  # Rounding mode. Defaults to an array of floors of the\r\n                  floor,  # same length as the others (or a scalar if so are the\r\n                  ceil,   # others).\r\n                  ceil\r\n                ],  \r\n    rpeMode = true, # If true the progression is RPE based, else it is\r\n                    # percentage based. Defaults to false.\r\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However his work ethic is without equal so he will always go to failure and sometimes past it and of course his warmup is like 5 kgs below his top sets. Since Brosef only has passing knowledge of percentages, he follows his gut. Interestingly, this means he uses RPE, who'd have thought?","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Brosef is a straight shooter, so he only uses one set scheme, but there is flexibility to create more complex set schemes and arrays of set schemes (see /assets/LiftingProgressions.jl) do create more complex progressions. However, our boi \"be grindin'\"–-evidenced by that one time he tried to sell you questionably-sourced protein powder–-he therefore has a straight forward progression that is still giving him linear gains in the same manner Jeffrey Epstein didn't kill himself. Of course, you've slowly been creeping up on him while being half his size but what do you know, you're reading the documentation for a super niche product instead of benching your ass off.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"TheGrind = Progression(;\r\n    type = LinearProgression(),\r\n    name = \"We Be Grindin'\",\r\n    sessions = 1,     # Number of different sessions in a week.\r\n    period = 1,       # Number of weeks in the period.\r\n    setScheme = TUT,  # Set scheme. The number of items here\r\n                      # must be equal to sessions * period.\r\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Brosef now has everything he needs to create his dream programme... aside from half repping bicep curls, quarter repping the leg press and training calves once a month after which he will be missing for a few days because \"he went too hard and crushed legs four days ago\", but this is enough for our purpose. He trains three days a week because he takes his recovery seriously and likes to party, so he can't no-life it like that jacked dude Brosef can totally out-bench.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Define the programme's concrete type. Can be used to extend `makeDays`.\r\nstruct BrosefDreamProgramme <: AbstractProgramme end\r\n\r\n# Define a dictionary that will contain an Exercise and its corresponding\r\n# progression as a tuple or vector.\r\nexerProg = Dict()\r\n\r\n# Push to the dictionary. Using named tuples is recommended and making the\r\n# key a string of the variable name makes things easier to follow.\r\npush!(\r\n    exerProg,\r\n    \"BenchPress\" => (exercise = BenchPress, progression = TheGrind),\r\n)\r\n\r\n# Define the training week. Extending this to multiple weeks and different days\r\n# can be done with arrays of arrays.\r\nweek = []\r\n# Push the days to the week.\r\npush!(week, BenchPress, TheGrind)\r\npush!(week, \"Rest\")\r\npush!(week, BenchPress, TheGrind)\r\npush!(week, \"Rest\")\r\npush!(week, BenchPress, TheGrind)\r\n\r\nProgramme(BrosefDreamProgramme(), \"BrosefDreamProgramme\", exerProg, week)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We need to create some dictionaries and arrays to hold the data as well as the type of the programme. This lets Julia work its multiple dispatch magic. There is also a function makeDays that can be extended to work with concrete subtypes of AbstractProgramme, allowing it to specialise for user defined programmes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To see a more advanced example that showcases the functionality of the package see function /assets/nSunsCAP3_OHP_6Day_LP.jl, in particular function makeDays in line 386.","category":"page"},{"location":"#FAQ-1","page":"Home","title":"FAQ","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"What makes a weightlifting program successful? Your hard work and dedication.     Greg Everett","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Is it overkill? Most definitely.\nWhat does it do? Lets you create and analyse lifting programmes.\nWhy not use a spreadsheet? This is more general and powerful than a spreadsheet but admittedly less approachable for less techy people.\nWhy not use an app instead? I use an app, Zero to Hero highly recommended. The premium version is cheap and lets you create and modify progressions, it is very, very good. I've also used TM Training in the past and it is also very good but can be annoyingly buggy. I can recommend them both. This serves a different purpose, it serves a more analytic and design-oriented purpose. The apps are great for logging.","category":"page"},{"location":"#Defaults-1","page":"Home","title":"Defaults","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"These are the default dictionaries defined in the programme. They are not explicitly exported so must be explicitly imported or accessed with the dot syntax:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"import Lifting: Lifting_Aux\r\n\r\nLifting.Lifting_Exercise_Names","category":"page"},{"location":"#","page":"Home","title":"Home","text":"They dictionaries define the following keys. Explore them to see what they contain, add what you need... or not use them at all!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> keys(Lifting_Aux)\r\nBase.KeySet for a Dict{String,Dict{String,String}} with 5 entries. Keys:\r\n  \"modality\"\r\n  \"setType\"\r\n  \"muscles\"\r\n  \"equipmentSize\"\r\n  \"equipment\"\r\n\r\njulia> keys(Lifting_Exercise_Names)\r\nBase.KeySet for a Dict{String,Dict{String,String}} with 10 entries. Keys:\r\n  \"grip\"\r\n  \"bench\"\r\n  \"squat\"\r\n  \"press\"\r\n  \"isometric\"\r\n  \"core\"\r\n  \"pull\"\r\n  \"row\"\r\n  \"deadlift\"\r\n  \"lowBack\"\r\n\r\njulia> keys(Lifting_Progressions)\r\nBase.KeySet for a Dict{String,Progression} with 14 entries. Keys:\r\n  \"AMRAP_Cali\"\r\n  \"nSuns_6Day_OHP\"\r\n  \"AMRAP_Grip\"\r\n  \"l23_lmh\"\r\n  \"m23_lmh\"\r\n  \"h23_lmh\"\r\n  \"CAP3_Bench_T1\"\r\n  \"CAP3_Row_T1\"\r\n  \"CAP3_Squat_T2\"\r\n  \"CAP3_Deadlift_T1\"\r\n  \"CAP3_Squat_T1\"\r\n  \"CAP3_Bench_T2\"\r\n  \"CAP3_Deadlift_T2\"\r\n  \"CAP3_Row_T2\"\r\n\r\njulia> keys(Lifting_Programmes)\r\nBase.KeySet for a Dict{String,Programme} with 1 entry. Keys:\r\n  \"nSunsCAP3_OHP_6Day_LP\"","category":"page"},{"location":"#Adding-to-the-Package-1","page":"Home","title":"Adding to the Package","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The recommended way for users to add their own creations to the package is to do so in the relevant /src/assets files and push them to their corresponding dictionaries. These can then be imported as normal. Users may also define their own modules that expand Lifting.jl's functionality. These user-made modules can then be imported instead. Alternatively, additions may be made in their local environments, it will simply crowd your workspace.","category":"page"},{"location":"io/#IO-1","page":"Input Output","title":"IO","text":"","category":"section"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"The package is capable of displaying programmes in the console, writing CSV files and using CSV files for plotting and analysis.","category":"page"},{"location":"io/#Displaying-1","page":"Input Output","title":"Displaying","text":"","category":"section"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"The default printing does a poor job of displaying the programme so we multiple dispatched our way into making it look pretty like Robert Oberst.","category":"page"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"println(::Programme, ::Any)","category":"page"},{"location":"io/#Base.println-Tuple{Programme,Any}","page":"Input Output","title":"Base.println","text":"println(programme::Programme, idx = 1:length(programme))\n\nPrints the programme in console in a nicely formatted style. Users can optionally provide an index, be it an integer, unit range, tuple or array. The index corresponds to the day. Function write writes to a csv and has the same indexing functionality.\n\nExamples\n\nprintln(MyProg)             # Prints whole programme.\nprintln(MyProg, 1)          # Prints day 1.\nndays = length(MyProg)      # Length returns the number of days.\nprintln(MyProg, 1:2:ndays)  # Prints every second day starting from the first.\nprintln(MyProg, [1, 5, 20]) # Prints days 1, 5 and 20 (also works with tuples).\n\n\n\n\n\n","category":"method"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"May the Programme be with you, always. This lets you do so, implement the programme in your favourite app, put on google sheets, log your progress, and then use that log to analyse your progress with loadLogFile and plotData. Alternatively be a monster and print everything out, who needs trees anyway?","category":"page"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"write(\r\n    ::AbstractString,\r\n    ::Programme,\r\n    ::Any;\r\n    ::Char,\r\n    ::Bool,\r\n)","category":"page"},{"location":"io/#Base.write-Tuple{AbstractString,Programme,Any}","page":"Input Output","title":"Base.write","text":"write(\n    filename::AbstractString,\n    programme::Programme,\n    idx = 1:length(programme);\n    delim::Char = ',',\n    log::Bool = false,\n)\n\nWrites programme to CSV. It defaults to delimiting the file with commas but you can choose your own. If log == true, generate a log file where users can log their progress. Automatically appends \"Log_\" to the start of the filename. Indexing works the same way as println.\n\nnote: Note\nThe log file will print every exercise in the programme, even those you may not care about. These can be deleted. However if you do so, make sure to change the number in cell [1,1] (top left) to the number of exercises you're keeping track of. This number is used by the programme to know how many columns to read.\n\n\n\n\n\n","category":"method"},{"location":"io/#Analysis-and-Utility-1","page":"Input Output","title":"Analysis and Utility","text":"","category":"section"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"If you've been logging your progress like a good lifter you can load it into Julia for some a n a l y t i c s.","category":"page"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"loadLogFile(programme::Dict, key)","category":"page"},{"location":"io/#Lifting.loadLogFile-Tuple{Dict,Any}","page":"Input Output","title":"Lifting.loadLogFile","text":"loadLogFile(programme::Dict, key)\n\nThis loads the log file and creates dictionaries of the values for all lifts. It drops missing values so the only thing you have to worry about is logging your progress properly. The function also assumes you've added your programmes to a dictionary, making it easier to analyse multiple programmes at once. It assumes the filename was generated by write.\n\nnote: Note\nIt's recommended a programme's key is the same as its name.\n\n\n\n\n\n","category":"method"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"Logs usually use dates, but we never want to know our progress as a function date do we? We want it as a function of time. This turns dates into number of days between the earliest date and the rest.","category":"page"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"numDays(dates; format = \"dd/mm/yyyy\")","category":"page"},{"location":"io/#Lifting.numDays-Tuple{Any}","page":"Input Output","title":"Lifting.numDays","text":"numDays(dates; format = \"dd/mm/yyyy\")\n\nTakes an array strings which represent dates in the format provided and calculates the number of days between the first and last entries.\n\n\n\n\n\n","category":"method"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"A picture is worth a thousand words, a lifter is worth at least half a human.","category":"page"},{"location":"io/#","page":"Input Output","title":"Input Output","text":"plotData(prog::Programme, names, x, y, args...; kwargs...)\r\nplotData!(figure, prog::Programme, names, x, y, args...; kwargs...)","category":"page"},{"location":"io/#Lifting.plotData-Tuple{Programme,Any,Any,Any,Vararg{Any,N} where N}","page":"Input Output","title":"Lifting.plotData","text":"plotData(prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\n\nPlot your hard earned progress with smooth curves and labels the figures appropriately. Skips missing values so your programme won't crash. Creates a new figure for each call, creating an array of figures. For mutating the same figure see [plotData!][@ref].\n\n\n\n\n\n","category":"method"},{"location":"io/#Lifting.plotData!-Tuple{Any,Programme,Any,Any,Any,Vararg{Any,N} where N}","page":"Input Output","title":"Lifting.plotData!","text":"plotData!(fig, prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\n\nSame as [plotData][@ref] but mutates the input figure.\n\n\n\n\n\n","category":"method"},{"location":"types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"The generalised framework for this package leans heavily on Julia's type system.","category":"page"},{"location":"types/#Primitive-Types-1","page":"Types","title":"Primitive Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"The abstract progression types let users create specialised functions.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"AbstractProgression\r\nAbstractProgramme","category":"page"},{"location":"types/#Lifting.AbstractProgression","page":"Types","title":"Lifting.AbstractProgression","text":"abstract type AbstractProgression end\nstruct LinearProgression <: AbstractProgression end\nstruct DoubleProgression <: AbstractProgression end\nstruct PeriodProgression <: AbstractProgression end\nstruct BlockProgression <: AbstractProgression end\n\nProgression types. Use these to make specialised functions and add new functionality.\n\n\n\n\n\n","category":"type"},{"location":"types/#Lifting.AbstractProgramme","page":"Types","title":"Lifting.AbstractProgramme","text":"AbstractProgramme\n\nProgramme types.\n\n\n\n\n\n","category":"type"},{"location":"types/#Structures-1","page":"Types","title":"Structures","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"In order to create programmes we need to create a set scheme. This is done via the SetScheme structure.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"SetScheme","category":"page"},{"location":"types/#Lifting.SetScheme","page":"Types","title":"Lifting.SetScheme","text":"mutable struct SetScheme{\n    T1 <: Union{<:AbstractString, Vector{<:AbstractString}},\n    T2 <: Union{<:Integer, Vector{<:Integer}},\n    T3 <: Union{<:Real, Vector{<:Real}},\n    T4 <: Union{<:Function, Vector{<:Function}},\n    T5 <: Bool,\n}\n    type::T1\n    sets::T2\n    reps::T2\n    intensity::T3\n    rpe::T3\n    addWeight::T3\n    roundMode::T4\n    wght::T3\n    rpeMode::T5\nend\n\nThis structure contains user-created set schemes. Its parameters are as follows:\n\ntype defines the set type,\nsets the number of sets of the corresponding type,\nreps is the number of reps in the set,\nintensity is the set intensity,\nrpe is the set's target RPE,\naddWeight is extra weight on top of the normally calculated weight (useful for chains, bands or microplates),\nwght is the set weight, which is calculated later when pairing progression schemes to exercises,\nrpeMode whether the set scheme is defined via RPE or percentage intensity, if true, the values in intensity will be assumed to be RPE and the percentage intensity will be calculated using RPE and the number of reps in the set, else the values in intensity will be used as provided.\n\nIt uses the following constructor, which takes care of any required computations.\n\nSetScheme(;\n    type::T1 = \"Default\",\n    sets::T2 = 5,\n    reps::T2 = 5,\n    intensity::T3 = 0.75,\n    addWeight::T4 = 0,\n    roundMode::T5 = floor,\n    rpeMode::Bool = false,\n) where {\n    T1 <: Union{<:AbstractString, Vector{<:AbstractString}},\n    T2 <: Union{<:Integer, Vector{<:Integer}},\n    T3 <: Union{<:Real, Vector{<:Real}},\n    T4 <: Union{<:Real, Vector{<:Real}},\n    T5 <: Union{<:Function, Vector{<:Function}},\n}\n\nEvery parameter has defaults, so users have the ability to provide only the ones they want to modify.\n\nIf rpeMode == true, intensity is based on RPE, which lies in the interval x  (0 10. If rpeMode == false, then intensity is relative to training max and therefore lies in the interval x  0 1. The lenghts of all input vectors must be equal.\n\nExample\n\nHere we define a smple set scheme and we are not asking for any added weight via addWeight, it becomes a zero vector.\n\njulia> SampleScheme = SetScheme(;\n           type = [\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"],\n           sets = [1, 2, 1, 1],\n           reps = [12, 14, 10, 5],\n           intensity = [9.5, 10, 10, 10 ],\n           roundMode = [floor, floor, ceil, ceil],\n           rpeMode = true,\n       )\nSetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}([\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"], [1, 2, 1, 1], [12, 14, 10, 5], [0.6538806237677003, 0.6275409806672554, 0.7041013906002465, 0.8309098462816784], [9.5, 10.0, 10.0, 10.0], [0.0, 0.0, 0.0, 0.0], Function[floor, floor, ceil, ceil], [0.0, 0.0, 0.0, 0.0], true)\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"After creating our desired set schemes we use them to create a progression.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Progression","category":"page"},{"location":"types/#Lifting.Progression","page":"Types","title":"Lifting.Progression","text":"mutable struct Progression{\n    T1 <: AbstractProgression,\n    T2 <: AbstractString,\n    T3 <: Integer,\n    T4 <: Union{<:SetScheme, Vector{<:SetScheme}},\n} <: AbstractProgression\n    type::T1\n    name::T2\n    sessions::T3\n    period::T3\n    setScheme::T4\nend\n\nThis structure holds user-defined progressions. Its parameters are as follows:\n\ntype is the progression type which is a subtype of AbstractProgression,\nname is the progression name,\nsessions is the number of different sessions in a week,\nperiod is the progression period,\nsetScheme is a previously defined set scheme or vector of set schemes, the length must be equal to sessions * period.\n\nThis structure lets users create different types of progressions, from simple day in day out progressions to complex undulating periodisation and block progressions.\n\nProgressions are created with the following constructor function,\n\nfunction Progression(;\n    type::T1,\n    name::T2,\n    sessions::T3 = 1,\n    period::T3 = 1,\n    setScheme::T4,\n) where {\n    T1 <: AbstractProgression,\n    T2 <: AbstractString,\n    T3 <: Integer,\n    T4 <: Union{<:SetScheme, Vector{<:SetScheme}},\n}\n\nExample\n\nAssuming we've run the example in SetScheme we can create a simple progression.\n\njulia> SampleProgression = Progression(;\n           type = LinearProgression(),\n           name = \"Progression Name\",\n           setScheme = SampleScheme,\n       )\nProgression{LinearProgression,String,Int64,SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}}(LinearProgression(), \"We Be Grindin'\", 1, 1, SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}([\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"], [1, 2, 1, 1], [12, 14, 10, 5], [0.6538806237677003, 0.6275409806672554, 0.7041013906002465, 0.8309098462816784], [9.5, 10.0, 10.0, 10.0], [0.0, 0.0, 0.0, 0.0], Function[floor, floor, ceil, ceil], [0.0, 0.0, 0.0, 0.0], true))\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"We also need to create an exercise.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Exercise","category":"page"},{"location":"types/#Lifting.Exercise","page":"Types","title":"Lifting.Exercise","text":"mutable struct Exercise{\n    T1 <: AbstractString,\n    T2 <: Union{AbstractString, Vector{<:AbstractString}},\n    T3 <: Union{AbstractString, Vector{<:AbstractString}},\n    T4 <: Union{AbstractString, Vector{<:AbstractString}},\n    T5 <: Union{AbstractString, Vector{<:AbstractString}},\n    T6 <: Real,\n    T7 <: Real,\n    T8 <: Function,\n}\n    name::T1\n    equipment::T2\n    modality::T3\n    size::T4\n    muscles::T5\n    trainingMax::T6\n    roundBase::T7\n    roundMode::T8\nend\n\nUser created exercises are encapsulated in this structure. Its parameters are as follows:\n\nname is the exercise name,\nequipment is the equipment required,\nmodality are any modifiers to the exercise (for example blocks),\nsize are the size/resistance of said modifiers (for example 2 inch),\nmuscles are the muscles targeted,\ntrainingMax is the training maximum used to calculate set weights when pairing with a progression,\nroundBase is the base to which set weights are rounded,\nroundMode is the rounding function used.\n\nThis uses the following constructor which provides default values for anything users don't need/want to track,\n\nfunction Exercise(;\n    name::T1,\n    equipment::T2 = \"NA\",\n    modality::T3 = \"Default\",\n    muscles::T4 = \"NA\",\n    trainingMax::T6 = 0,\n    size::T5 = \"NA\",\n    roundBase::T7 = 2.5,\n    roundMode::T8 = floor,\n) where {\n    T1 <: AbstractString,\n    T2 <: Union{AbstractString, Vector{<:AbstractString}},\n    T3 <: Union{AbstractString, Vector{<:AbstractString}},\n    T4 <: Union{AbstractString, Vector{<:AbstractString}},\n    T5 <: Union{AbstractString, Vector{<:AbstractString}},\n    T6 <: Real,\n    T7 <: Real,\n    T8 <: Function,\n}\nend\n\nExamples\n\nSay we want to bench press off a 1 inch block and a semi supinated grip on a swiss bar. We can easily create this exercise\n\njulia> BenchAccessory = Exercise(;\n           name = \"Swiss Bar Bench\",\n           modality = [\"Block\" , \"Semi-Supinated\"],\n           equipment = \"Swiss Bar\",\n           size = \"1 inch\",\n           muscles = [\"Pecs\", \"Triceps\", \"Front Delts\"],\n           trainingMax = 100,\n           roundBase = 2.5,\n           roundMode = floor,\n       )\nExercise{String,String,Array{String,1},String,Array{String,1},Float64,Float64,typeof(floor)}(\"Swiss Bar Bench\", \"Swiss Bar\", [\"Block\", \"Semi-Supinated\"], \"1 inch\", [\"Pecs\", \"Triceps\", \"Front Delts\"], 100.0, 2.5, floor)\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"Programme","category":"page"},{"location":"types/#Lifting.Programme","page":"Types","title":"Lifting.Programme","text":"struct Programme{\n    T1 <: AbstractProgramme,\n    T2 <: AbstractString,\n    T3 <: Dict{Any, Any},\n    T4 <: Any,\n}\n    type::T1\n    name::T2\n    exerProg::T3\n    days::T4\nend\n\nUser created programmes are made with this structure. The parameters are as follows:\n\ntype is the exercise type and is a subtype of AbstractProgramme (we recommend users define custom concrete types for their programmes),\nname is the programme name (we recommend the name is the same as the programme type),\nexerProg is a dictionary which pairs exercises and progressions with the key-value pair name => (exercise, progression).\ndays is the programme schedule where each entry has all the exercise for the day so arrays of arrays are recommended.\n\n\n\n\n\n","category":"type"}]
}

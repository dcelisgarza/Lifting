<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · Lifting.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Lifting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Lifting.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../io/">IO</a></li><li class="is-active"><a class="tocitem" href>Types</a><ul class="internal"><li><a class="tocitem" href="#Primitive-Types-1"><span>Primitive Types</span></a></li><li><a class="tocitem" href="#Structures-1"><span>Structures</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Functions &amp; Methods</a></li><li><a class="tocitem" href="../dictionaries/">Defaults</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dcelisgarza/Lifting.jl/blob/master/docs/src/types.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h1><pre><code class="language-julia">abstract type AbstractAnimal end
abstract type AbstractPrimate &lt;: AbstractAnimal end
abstract type AbstractHuman &lt;: AbstractPrimate end
struct Person &lt;: AbstractHuman end</code></pre><p>The generalised framework for this package leans heavily on Julia&#39;s type system.</p><h2 id="Primitive-Types-1"><a class="docs-heading-anchor" href="#Primitive-Types-1">Primitive Types</a><a class="docs-heading-anchor-permalink" href="#Primitive-Types-1" title="Permalink"></a></h2><blockquote><p>The more primitive a man is the better he believes himself to be.</p><ul><li>Erich Maria Remarque on idiots</li></ul></blockquote><p>The abstract progression types let users create specialised functions.</p><article class="docstring"><header><a class="docstring-binding" id="Lifting.AbstractProgression" href="#Lifting.AbstractProgression"><code>Lifting.AbstractProgression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractProgression end
struct LinearProgression &lt;: AbstractProgression end
struct DoubleProgression &lt;: AbstractProgression end
struct PeriodProgression &lt;: AbstractProgression end
struct BlockProgression &lt;: AbstractProgression end</code></pre><p>Progression types. Use these to make specialised functions and add new functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/Lifting.jl/blob/265c22d0418787b2b55551e74dbdedd18aaeccfe/src/LiftingTypes.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lifting.AbstractProgramme" href="#Lifting.AbstractProgramme"><code>Lifting.AbstractProgramme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractProgramme</code></pre><p>Programme types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/Lifting.jl/blob/265c22d0418787b2b55551e74dbdedd18aaeccfe/src/LiftingTypes.jl#LL17-L22">source</a></section></article><h2 id="Structures-1"><a class="docs-heading-anchor" href="#Structures-1">Structures</a><a class="docs-heading-anchor-permalink" href="#Structures-1" title="Permalink"></a></h2><blockquote><p>Ideas that require people to reorganize their picture of the world provoke hostility.</p><ul><li>James Gleick on organising things</li></ul></blockquote><p>In order to create programmes we need to create a set scheme. This is done via the <a href="#Lifting.SetScheme"><code>SetScheme</code></a> structure.</p><article class="docstring"><header><a class="docstring-binding" id="Lifting.SetScheme" href="#Lifting.SetScheme"><code>Lifting.SetScheme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SetScheme{
    T1 &lt;: Union{&lt;:AbstractString, Vector{&lt;:AbstractString}},
    T2 &lt;: Union{&lt;:Integer, Vector{&lt;:Integer}},
    T3 &lt;: Union{&lt;:Real, Vector{&lt;:Real}},
    T4 &lt;: Union{&lt;:Function, Vector{&lt;:Function}},
    T5 &lt;: Bool,
}
    type::T1
    sets::T2
    reps::T2
    intensity::T3
    rpe::T3
    addWeight::T3
    roundMode::T4
    wght::T3
    rpeMode::T5
end</code></pre><p>This structure contains user-created set schemes. Its parameters are as follows:</p><ul><li><code>type</code> defines the set type,</li><li><code>sets</code> the number of sets of the corresponding type,</li><li><code>reps</code> is the number of reps in the set,</li><li><code>intensity</code> is the set intensity,</li><li><code>rpe</code> is the set&#39;s target RPE,</li><li><code>addWeight</code> is extra weight on top of the normally calculated weight (useful for chains, bands or microplates),</li><li><code>wght</code> is the set weight, which is calculated later when pairing progression schemes to exercises,</li><li><code>rpeMode</code> whether the set scheme is defined via RPE or percentage intensity, if true, the values in <code>intensity</code> will be assumed to be RPE and the percentage intensity will be calculated using RPE and the number of reps in the set, else the values in <code>intensity</code> will be used as provided.</li></ul><p>It uses the following constructor, which takes care of any required computations.</p><pre><code class="language-none">SetScheme(;
    type::T1 = &quot;Default&quot;,
    sets::T2 = 5,
    reps::T2 = 5,
    intensity::T3 = 0.75,
    addWeight::T4 = 0,
    roundMode::T5 = floor,
    rpeMode::Bool = false,
) where {
    T1 &lt;: Union{&lt;:AbstractString, Vector{&lt;:AbstractString}},
    T2 &lt;: Union{&lt;:Integer, Vector{&lt;:Integer}},
    T3 &lt;: Union{&lt;:Real, Vector{&lt;:Real}},
    T4 &lt;: Union{&lt;:Real, Vector{&lt;:Real}},
    T5 &lt;: Union{&lt;:Function, Vector{&lt;:Function}},
}</code></pre><p>Every parameter has defaults, so users have the ability to provide only the ones they want to modify.</p><p>If <code>rpeMode == true</code>, intensity is based on RPE, which lies in the interval <span>$x ∈ (0, 10]$</span>. If <code>rpeMode == false</code>, then intensity is relative to training max and therefore lies in the interval <span>$x ∈ [0, 1]$</span>. The lenghts of all input vectors must be equal.</p><p><strong>Example</strong></p><p>Here we define a simple set scheme. Since we are not providing any added weight via <code>addWeight</code>, that parameter becomes a zero vector.</p><pre><code class="language-none">julia&gt; SampleScheme = SetScheme(;
           type = [&quot;Long Rest&quot;, &quot;Longer Rest&quot;, &quot;Longest Rest&quot;, &quot;Optional Forced Reps&quot;],
           sets = [1, 2, 1, 1],
           reps = [12, 14, 10, 5],
           intensity = [9.5, 10, 10, 10],
           roundMode = [floor, floor, ceil, ceil],
           rpeMode = true,
       )
SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}([&quot;Long Rest&quot;, &quot;Longer Rest&quot;, &quot;Longest Rest&quot;, &quot;Optional Forced Reps&quot;], [1, 2, 1, 1], [12, 14, 10, 5], [0.6538806237677003, 0.6275409806672554, 0.7041013906002465, 0.8309098462816784], [9.5, 10.0, 10.0, 10.0], [0.0, 0.0, 0.0, 0.0], Function[floor, floor, ceil, ceil], [0.0, 0.0, 0.0, 0.0], true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/Lifting.jl/blob/265c22d0418787b2b55551e74dbdedd18aaeccfe/src/LiftingTypes.jl#LL259-L325">source</a></section></article><p>After creating our desired set schemes we use them to create a progression.</p><article class="docstring"><header><a class="docstring-binding" id="Lifting.Progression" href="#Lifting.Progression"><code>Lifting.Progression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Progression{
    T1 &lt;: AbstractProgression,
    T2 &lt;: AbstractString,
    T3 &lt;: Integer,
    T4 &lt;: Union{&lt;:SetScheme, Vector{&lt;:SetScheme}},
} &lt;: AbstractProgression
    type::T1
    name::T2
    sessions::T3
    period::T3
    setScheme::T4
end</code></pre><p>This structure holds user-defined progressions. Its parameters are as follows:</p><ul><li><code>type</code> is the progression type which is a subtype of <a href="#Lifting.AbstractProgression"><code>AbstractProgression</code></a>,</li><li><code>name</code> is the progression name,</li><li><code>sessions</code> is the number of different sessions in a week,</li><li><code>period</code> is the progression period,</li><li><code>setScheme</code> is a previously defined set scheme or vector of set schemes, the length must be equal to <code>sessions * period</code>.</li></ul><p>This structure lets users create different types of progressions, from simple day in day out progressions to complex undulating periodisation and block progressions.</p><p>Progressions are created with the following constructor function,</p><pre><code class="language-none">function Progression(;
    type::T1,
    name::T2,
    sessions::T3 = 1,
    period::T3 = 1,
    setScheme::T4,
) where {
    T1 &lt;: AbstractProgression,
    T2 &lt;: AbstractString,
    T3 &lt;: Integer,
    T4 &lt;: Union{&lt;:SetScheme, Vector{&lt;:SetScheme}},
}</code></pre><p><strong>Example</strong></p><p>Assuming we&#39;ve run the example in <a href="#Lifting.SetScheme"><code>SetScheme</code></a> we can create a simple progression.</p><pre><code class="language-none">julia&gt; SampleProgression = Progression(;
           type = LinearProgression(),
           name = &quot;Progression Name&quot;,
           setScheme = SampleScheme,
       )
Progression{LinearProgression,String,Int64,SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}}(LinearProgression(), &quot;Progression Name&quot;, 1, 1, SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}([&quot;Long Rest&quot;, &quot;Longer Rest&quot;, &quot;Longest Rest&quot;, &quot;Optional Forced Reps&quot;], [1, 2, 1, 1], [12, 14, 10, 5], [0.6538806237677003, 0.6275409806672554, 0.7041013906002465, 0.8309098462816784], [9.5, 10.0, 10.0, 10.0], [0.0, 0.0, 0.0, 0.0], Function[floor, floor, ceil, ceil], [0.0, 0.0, 0.0, 0.0], true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/Lifting.jl/blob/265c22d0418787b2b55551e74dbdedd18aaeccfe/src/LiftingTypes.jl#LL404-L455">source</a></section></article><p>We also need to create an exercise.</p><article class="docstring"><header><a class="docstring-binding" id="Lifting.Exercise" href="#Lifting.Exercise"><code>Lifting.Exercise</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Exercise{
    T1 &lt;: AbstractString,
    T2 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T3 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T4 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T5 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T6 &lt;: Real,
    T7 &lt;: Real,
    T8 &lt;: Function,
}
    name::T1
    equipment::T2
    modality::T3
    size::T4
    muscles::T5
    trainingMax::T6
    roundBase::T7
    roundMode::T8
end</code></pre><p>User created exercises are encapsulated in this structure. Its parameters are as follows:</p><ul><li><code>name</code> is the exercise name,</li><li><code>equipment</code> is the equipment required,</li><li><code>modality</code> are any modifiers to the exercise (for example blocks),</li><li><code>size</code> are the size/resistance of said modifiers (for example 2 inch),</li><li><code>muscles</code> are the muscles targeted,</li><li><code>trainingMax</code> is the training maximum used to calculate set weights when pairing with a progression,</li><li><code>roundBase</code> is the base to which set weights are rounded,</li><li><code>roundMode</code> is the rounding function used.</li></ul><p>This uses the following constructor which provides default values for anything users don&#39;t need/want to track,</p><pre><code class="language-none">function Exercise(;
    name::T1,
    equipment::T2 = &quot;NA&quot;,
    modality::T3 = &quot;Default&quot;,
    muscles::T4 = &quot;NA&quot;,
    trainingMax::T6 = 0,
    size::T5 = &quot;NA&quot;,
    roundBase::T7 = 2.5,
    roundMode::T8 = floor,
) where {
    T1 &lt;: AbstractString,
    T2 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T3 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T4 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T5 &lt;: Union{AbstractString, Vector{&lt;:AbstractString}},
    T6 &lt;: Real,
    T7 &lt;: Real,
    T8 &lt;: Function,
}
end</code></pre><p><strong>Examples</strong></p><p>Say we want to bench press off a 1 inch block and a semi supinated grip on a swiss bar. We can easily create this exercise</p><pre><code class="language-none">julia&gt; BenchAccessory = Exercise(;
           name = &quot;Swiss Bar Bench&quot;,
           modality = [&quot;Block&quot; , &quot;Semi-Supinated&quot;],
           equipment = &quot;Swiss Bar&quot;,
           size = &quot;1 inch&quot;,
           muscles = [&quot;Pecs&quot;, &quot;Triceps&quot;, &quot;Front Delts&quot;],
           trainingMax = 100,
           roundBase = 2.5,
           roundMode = floor,
       )
Exercise{String,String,Array{String,1},String,Array{String,1},Float64,Float64,typeof(floor)}(&quot;Swiss Bar Bench&quot;, &quot;Swiss Bar&quot;, [&quot;Block&quot;, &quot;Semi-Supinated&quot;], &quot;1 inch&quot;, [&quot;Pecs&quot;, &quot;Triceps&quot;, &quot;Front Delts&quot;], 100.0, 2.5, floor)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/Lifting.jl/blob/265c22d0418787b2b55551e74dbdedd18aaeccfe/src/LiftingTypes.jl#LL496-L568">source</a></section></article><p>Finally, we create a programme using the following structure.</p><article class="docstring"><header><a class="docstring-binding" id="Lifting.Programme" href="#Lifting.Programme"><code>Lifting.Programme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Programme{
    T1 &lt;: AbstractProgramme,
    T2 &lt;: AbstractString,
    T3 &lt;: Dict{Any, Any},
    T4 &lt;: Vector{Any},
}
    type::T1
    name::T2
    exerProg::T3
    days::T4
end</code></pre><p>User created programmes are made with this structure. The parameters are as follows:</p><ul><li><code>type</code> is the exercise type and is a subtype of <a href="#Lifting.AbstractProgramme"><code>AbstractProgramme</code></a> (we recommend users define custom concrete types for their programmes),</li><li><code>name</code> is the programme name (we recommend the name is the same as the programme type),</li><li><code>exerProg</code> is a dictionary which pairs exercises and progressions with the key-value pair <code>name =&gt; (exercise, progression)</code>.</li><li><code>days</code> is the programme schedule where each entry in the vector has all the exercises for the day.</li></ul><p>Each programme is different so the recommendation is to create a typed <a href="../functions/#Lifting.makeDays-Tuple{}"><code>makeDays</code></a> function for the programme type.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><a href="../functions/#Lifting.makeDays-Tuple{}"><code>makeDays</code></a> must be explicitly imported either with <code>import Lifting: makeDays</code> or <code>Lifting.makeDays</code> for it to be automatically used in <a href="../functions/#Lifting.updateMaxes!-Tuple{Programme,Any,Any}"><code>updateMaxes!</code></a>.</p></div></div><p><strong>Examples</strong></p><p>Assuming we are using the previously defined <a href="#Lifting.Exercise"><code>Exercise</code></a> and <a href="#Lifting.Progression"><code>Progression</code></a>, we can create a programme. There are a few ways to do so but this is recommended.</p><pre><code class="language-julia"># Define the programme&#39;s concrete type. Can be used to extend `makeDays`.
struct SampleProgramme &lt;: AbstractProgramme end

# Define a dictionary that will contain an Exercise and its corresponding
# progression as a tuple or vector.
exerProg = Dict()

# Push exercises and progressions to dictionary. Using named tuples is
# recommended because it enables dot syntax as well as regular indexing.
# Each exercise is paired with its progression.
push!(
    exerProg,
    &quot;BenchAccessory&quot; =&gt; (exercise = BenchAccessory, progression = SampleProgression),
)

# Define the a function that creates the schedule. This lets you automatically
# update training maxes and makes changing the programme easier. Here we also
# define rest days but you can leave them out if need be. `makeDays` will be
# called for whatever type is given as its first argument. Different programme
# types will necessarily have and call different `makeDays` functions.
import Lifting: makeDays
function makeDays(::SampleProgramme, exerProg)

    # One sub array per day you want to track.
    week = [[], [], [], [], [], [], []]

    # You can &#39;unroll&#39; the dictionary contents or push them directly to your
    # schedule. If using named tuples dot syntax and normal numeric indexing
    # both work
    # exerProg[&quot;BenchAccessory&quot;].exercise == exerProg[&quot;BenchAccessory&quot;][1]
    BenchAccessory = exerProg[&quot;BenchAccessory&quot;].exercise
    BenchAccessoryProg = exerProg[&quot;BenchAccessory&quot;].progression


    # Push the exercise and progression to whichever day of the week you want.
    # If the progression has multiple set schemes, the corresponding scheme can
    # be accessed by adding the index as the last argument.
    # push!(week[1], BenchAccessory, BenchAccessoryProg, 2)
    # Which would fail because there is only one set scheme, but if
    # BenchAccessoryProg were to have more entries that would take the second.
    # push! is overloaded so it also automatically calculates the required
    # weights. You can do this manually but this is easier and more reliable.
    push!(week[1], BenchAccessory, BenchAccessoryProg)   # Day 1
    push!(week[2], &quot;Rest&quot;)  # Day 2
    push!(week[3], BenchAccessory, BenchAccessoryProg)   # Day 3
    push!(week[4], &quot;Rest&quot;)  # Day 4
    push!(week[5], BenchAccessory, BenchAccessoryProg)   # Day 5
    push!(week[5], &quot;Rest&quot;)  # Day 6
    push!(week[7], &quot;Rest&quot;)  # Day 7

    return week
end

# Create weekly schedule.
week = makeDays(SampleProgramme(), exerProg)

# Create programme.
sampleProgramme = Programme(
                            SampleProgramme(),
                            &quot;SampleProgramme&quot;,
                            exerProg,
                            week
                        )</code></pre><p>It&#39;s recommended users either import the default dictionary <a href="../dictionaries/#Lifting.Lifting_Programmes"><code>Lifting_Programmes</code></a> and store their programmes there with key equal to the programme name and type. They can also create their own dictionary for their own creations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/Lifting.jl/blob/265c22d0418787b2b55551e74dbdedd18aaeccfe/src/LiftingTypes.jl#LL663-L758">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../io/">« IO</a><a class="docs-footer-nextpage" href="../functions/">Functions &amp; Methods »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 April 2020 20:08">Thursday 30 April 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
